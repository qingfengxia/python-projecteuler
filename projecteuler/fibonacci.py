"""
####################background ############################
 for even number: I found  20
    fib(20)=fib(10)*fib(11)+fib(9)*fib(10)=fib(10)*(fib(9)+fib(11))

 It is called: Cassini formula
Then, how to calc the next fibonacci number, if you know  nth fib number?
fib(n-1)=fib(n)-fib(n-2)

Since the golden ratio between fib(n) and fib(n-1)   : (a + b)/a=a /b
fib(n+1)/fib(n)  is approaching to a fixed value?
it can be used to search the nth fib number

##################################################
Problem 2 
Each new term in the Fibonacci sequence is generated by adding the previous two terms. 
By starting with 1 and 2, the first 10 terms will be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values 
do not exceed four million, find the sum of the even-valued terms.

##################################################
"""

from __future__ import print_function

#fist 40, 40th has 9 digits,  is nearly every 6 numbers to increase 10 times 
fib_seq=[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141]
len_fib_seq=len(fib_seq)
#print len_fib_seq
fib_ratio=1.61803398875  #fib(n+1)/fib(n)

def fibonacci(nth):
    """  recursive form, according to definition 
    """
    if nth>30:
        print("nth is too big for ")
        return -1
    elif nth> 2:
            return fibonacci(nth-1) + fibonacci(nth-2)
    else:
            if nth== 1:
                    return 1
            if nth== 2:
                    return 1

#fib=fibonacci    #alias yes!

def fib_K_plus_L(t1, t2):
    ( fL, fLp1, Lth) = tuple(t1)  # select the best fib(l)
    ( fK, fKp1, Kth) = tuple(t2)  # can this avoid copy of big object???
    nth = Kth +Lth
    fn=fK*fLp1+(fKp1-fK)*fL
    fnp1=fKp1*fLp1 + fK*fL
    return (fn, fnp1, nth)


def fib(nth):
    """ fast looking up the predefined list, then use fib_K_plus_L
        validate by http://www.maths.surrey.ac.uk/hosted-sites/R.Knott/Fibonacci/fibCalcX.html
    """
    if nth<=len_fib_seq:
        if nth<0:
            raise Exception('The input should only be postive integer! ')
        return fib_seq[nth-1]   # minus index is valid for python!, not for C++. it cause error some time
    else:
        base=len_fib_seq-1
        N=nth/base
        q=nth%base 
        #print base, N, q
        t0=(fib_seq[base-1], fib_seq[base], base)
        t_step=t0
        t1=t0
        i=N-1
        while i>0:
            #print i, t1, q
            t1= fib_K_plus_L(t1, t_step)
            i=i-1
        if q>0:
            t1 = fib_K_plus_L(t1, (fib(q), fib(q+1), q))  #fib(0) it also generate some value, but erroous!
        return t1[0]
    
def problem104():
    raise Exception("This method is not implemented yet")
    n=2749
    f=fib_bigNth(n)[0]
    

def fib_bigNth(bigNth):
    """
    return  (Fk, Fk+1, k)   using (f,) or ret[0] to receive the kth Fibonacci
    """
    if bigNth <1 or type(bigNth) != type(1):  
        raise Exception("Fibonacci is defined only for postive integer")
    b="{0:b}".format(bigNth)   # pyhton3.x it may change to  0bXXXXXXX
    e=len(b)
    #print "debug output, int->binary, the first must be 1, ",b, e  
    # m=base*2**i 
    l=fib_2exp_list(base=1, nTuples=e)
    t=l[-1]  #first is the highest bit!, must be 1, but tuple list, highest is the last
    #print l #debug output,  bool('0') is True, bool('') is False!
    for i in range(1,e):
        if (b[i]=='1'):   
            #print "index",i,b[i], l[e-i-1], "\n"
            t=fib_K_plus_L(t, l[e-i-1])         #better to reverse list of tuples, easy to make index error!
    #return t[0]
    return t        

def fib_bigNth_test():
    bigNth=100
    print("test fib_bigNth(), with bigNth=", bigNth)
    print(fib_bigNth(bigNth))

def show_ratio():
    l=generate_first_N_fib(42)
    ratios= [ l[i+1]/float(l[i]) for i in range(39) ]
    print(ratios)

def fib_reserve_lookup(cond):
    """ For the given condition function, find nth
    if cond(fib(nth)) do the search
    """
    return -1

def generate_first_N_fib(N):
    """generate the first N fibonacci number
    """
    l=N*[None]
    seq=len(fib_seq)
    l[:seq]=fib_seq
    #print seq, N
    for i in range(seq,N):
        #print nth, fib(nth)
        l[i]=fib(i+1)
    return l

def fib_2exp_list(base, nTuples):
    """  give list of 2-tuple (fib(m), fib(m+1) ) ,where m=base*2**i, i = list index
        base must be a even number, it is usful to find fibonacci number for a large number
        BASE*10**i should be more usful, but if base=2, then it also good for hex number
    """
    m=base
    l=[( fibonacci(base), fibonacci(base+1), m)]
    for i in range(1,nTuples):  
        ( fm, fmp1, m) = l[i-1]
        f2m=fm*(fmp1-fm+fmp1)
        f2mp2=fmp1*(fm+fmp1+fm)
        f2mp1=f2mp2-f2m
        m=base*2**i
        tuple=( f2m, f2mp1, m)
        l.append(tuple)
    return l


from sys import version_info
# for python 2.x, there is L for Long int, 3.x no such suffix
# from types import *
# type(number)==types.LongType   # type(number) == type(0L)  
# type check is time consuming
if version_info[0] >=3:           # tuple list, uisng [index]
    def digits_count(number):
        l=len(str(number))
        return l
else:
    def digits_count(number):
        # for python 2.x, there is L for Long int, 3.x no such suffix
        l=len(str(long(number)))
        #if number is long   
        #    l=l-1
        return l

def digit_count_approximate(Ndigits):
    #the base can be estimated by  
    from math import log
    # fib_ratio=1.61803398875           it is almost fixed sicne 20th, the golden ratios
    print("the n is apporximately =",log(10,fib_ratio)*(Ndigits-9)+40 ) #40th fib is the first 9 number
    # for every 100th number, the digits increase by 21,  fib(100) has the 21digits
    
    
def fib_test():
    f20=fib(11)*fib(10)+fib(10)*fib(9)
    print(fib_K_plus_L( (5,8,5), (8,13,6)), "=?", (fib(11), fib(12), 11)) # correctly
    assert "f20=fib(20)"     #sort of eval()
    #ul=fib_2exp_list(10,10)  #int auto cast to Long, no overflow!
    #print [n/m for (m,n,nth) in ul]        #long integer division ???
    """
    print "fib(0)=",digits_count(fib(0)), fib(0)
    print "fib(48)=",digits_count(fib(48)), fib(48)
    print "fib(100)=",digits_count(fib(100)), fib(100)
    print "fib(125)=",digits_count(fib(125)), fib(125)
    print "200nth fib =", fib(200)
    print "digits_count(fib(200))=",digits_count(fib(200))
    """
        
def main():
    from timeit import timeit
    #timeit(sum_fibobacci_even_below_N, 4000000)  # this cause an error, the program will not stop
     
    #show_ratio()
    
    fib_bigNth_test()
    #fib_test()
    #wait=raw_input("wait any key to eixt")
    #print digits_count(1234567890L)    #correctly

    #print digits_count(fib(40))
    
    digit_count_approximate(1000) # 4781.90721908 ->4782

    
if __name__ == "__main__":
    main()